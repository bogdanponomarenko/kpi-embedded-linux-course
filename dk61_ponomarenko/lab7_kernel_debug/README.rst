Лабораторна робота № 7
======================

``Тема``: Debugfs, налагодження ядра
++++++++++++++++++++++++++++++++++++

Завдання
________

– розібратися с debugfs

– додати до попередньої лабораторної роботи можливість зчитувати і писати в буфери за допомогою debugfs (при відкриванні файлу і аллкокації буффера, 
в debugfs створюється entry з іменем в виді адресу file, вмістом в якості blob)

– розібратися з відладкою модулів ядра засобами GDB

– спробувати налагоджувати модуль hive засобами gdb на ядрі, запущеному в qemu

– спробувати крашнути ядро, записати crash dump і потім дослідити його за допомогою crash (замість крашнути можна використати sysrq)

– результати двох попередніх пунктів додати в звіт

– підготуватись продемонструвати при захисті

:Примітка: лабораторна робота заснована на виконанні  `попередньої <https://github.com/kpi-keoa/kpi-embedded-linux-course/tree/master/dk62_dovzhenko/lab5_6_character_device/>`_, проте в 5-6 роботі використовувалося звичайне бінарне дерево, а в даній буде використано дерево під назвою "червоно-чорне".


red-black tree
______________

Теорія
~~~~~~

Червоно-чорне дерево (англ. red-black tree, англ. RB tree) — різновид самозбалансованого бінарного дерева пошуку, вершини якого мають додаткові властивості (RB-властивості), зокрема «колір» (червоний або чорний). 

Бінарне дерево називається червоно-чорним, якщо воно має такі властивості:

#. кожна вершина або червона, або чорна
#. корінь дерева — чорний
#. кожний лист (NIL) — чорний
#. якщо вершина червона, обидві її дочірні вершини чорні (інакше, батько червоної вершини — чорний)
#. усі прості шляхи від будь-якої вершини до листів мають однакову кількість чорних вершин

Візуальний риклад такого дерева:

.. image:: img/red-black_tree_example.png

В деяких зображеннях червоно-чорних дерев, NIL-листки не наводяться, тому що вони не містять корисної інформації, але їхнє існування необхідне для забезпечення усіх властивостей.

Реалізація
~~~~~~~~~~

Функція вставки
"""""""""""""""

Потрібно проходити по дереву, поки не знайдено "листовий" вузол, де буде відбуватися вставка. Як тільки знайдено це місце, новий вузол вставляється як «червоний», і дерево при необхідності перебалансовується. Код реалізовано наступним чином:

.. code-block:: c

	void ftree_add (struct hive_flist_item *item, struct rb_root *root)
	{
		struct rb_node **link = &root->rb_node, *parent;
		struct file *val4cmp = item->file;
		while(*link) {
			parent = *link;
			struct hive_flist_item *strp = rb_entry(parent, struct hive_flist_item,
				node);
			if (strp->file > val4cmp)
				link = &(*link)->rb_left;
			else
				link = &(*link)->rb_right;
		}
		rb_link_node(&item->node, parent, link);
		rb_insert_color(&item->node, root);
	}

Щоб використовувати таке дерево слід підключити «#include <linux / rbtree.h>».

Створення нового rbtree
"""""""""""""""""""""""

Вузли даних в дереві rbtree - це структури, що містять елемент struct rb_node:

.. code-block:: c

	struct rb_node node;

При роботі з вказівником на вбудовану структуру rb_node доступ до структури даних можна отримати за допомогою стандартного макроса container_of (). Крім того, окремі члени можуть бути доступні безпосередньо через rb_entry (вузол, тип, член).

У корені кожного rbtree знаходиться структура rb_root, яка ініціалізується як порожня через:

.. code-block:: c

	struct rb_root the_root = RB_ROOT;

Про Kconfig
__________________

Механізм **Kconfig** є сьогодні стандартним механізмом конфігурації і використовується провідними проектами з відкритим вихідним кодом, такими як *ядро Linux*, *Busybox* і *uClibc*. **Kconfig** має базовий синтаксис конфігурації, який дозволяє додавати параметри конфігурації різних типів, створювати залежності і писати кілька рядків опису.

Ядро Linux містить файл *Kconfig* майже для кожного каталогу. 
Кожен файл Kconfig налаштовує свій власний рівень.

**Деякі функції для конфігурації:** [1]_

* **make config** - текстова конфігурація. Параметри пропонуються один за одним. На всі варіанти потрібно відповісти, а доступ до попередніх опцій неможливий;

* **make menuconfig** - псевдо графічне меню на основі *ncurses* (лише введення тексту). Потрібно перейти до меню, щоб змінити потрібні параметри;

* **make defconfig** - створює новий конфігураційний файл з настройками за замовчуванням, які беруться з архітектурно-залежних *defconfig* файлів. Використовують цю опцію, щоб знову створити конфігураційний файл з налаштуваннями за замовчуванням, аналогічно як в архіві з вихідним кодом.

* **make nconfig** - псевдо графічне меню на основі ncurses. Потрібно встановити `sys-libs/ncurses <https://packages.gentoo.org/packages/sys-libs/ncurses>`_.

* **make xconfig** - конфігуратор з графічним інтерфейсом заснований на *Qt4*. потрібн підключити `<dev-qt/qtgui https://packages.gentoo.org/packages/dev-qt/qtgui>`_

* **make oldconfig** - переглядається відміність між версіями ядра та оновляється, щоб створити новий ``.config`` для ядра;

* **make allyesconfig** - вмикає всі параметри конфігурації в ядрі. Він встановлює для всіх параметрів ядра ``*``. **Потрібно переконатися, що перед використанням цієї опції отримано резервну копію поточної конфігурації ядра!**


Debugfs
_______

Теорія
~~~~~~	

:debugfs: - це спеціальна файлова система, доступна в ядрі *Linux* починаючи з версії 2.6.10-rc3.

Debugfs існує як простий спосіб для розробників ядра збирати інформацію доступно для робочих просторів. На відміну від ``/proc``, який призначений тільки для інформації про процес, або ``sysfs``, який має суворі правила одне значення для файлу, У ``debugfs`` немає ніяких правил. Розробники можуть розмістити будь-яку інформацію, яку бажають. 

**Існує багато функцій числових, булевих значень або фрагментів пам'яті (в основному текстових), ось дякі з них:** [2]_

``struct dentry * debugfs_create_u8 (const char * name, режим umode_t, struct dentry * parent, значение u8 *);`` - створює файл debugfs, який використовується для читання і запису 8-розрядного значення без знака;

``struct dentry *debugfs_create_bool(const char *name, umode_t mode, struct dentry *parent, bool *value);`` - створює файл debugfs, який використовується для читання і запису логічного значення;

``struct dentry *debugfs_create_blob(const char *name, umode_t mode, struct dentry *parent, struct debugfs_blob_wrapper *blob);`` - створює файл debugfs, який використовується для читання двійкового довічного об'єкта


Використання debugfs
~~~~~~~~~~~~~~~~~~~~

Код, що використовує debugfs, підключається за допомогою ``<linux/debugfs.h>``.
Перший кроков, це було створення католога в системі debugfs.

.. code-block:: c

	debugfs_folder = debugfs_create_dir(DIR, NULL);
	if (!debugfs_folder) {
		printk(KERN_INFO,"debugfs_folder creation failed!\n");
	}

Розглянемо функцію **debugfs_create_dir** детальніше:

.. code-block:: c

	struct dentry * debugfs_create_dir (const char *name, struct dentry *parent);

де,
	* *name* - вказівник на рядок, що містить ім'я каталогу для створення.
	* *parent* - вказівник на *батьківський* dentry для цього файлу. Це має бути каталог dentry, якщо він встановлений. Якщо цей параметр має значення **NULL**, каталог буде створений в корені файлової системи debugfs.

:Короткий опис: Ця функція створює каталог в *debugfs* із заданим ім'ям. Така функція поверне вказівнк на dentry, якщо все виконається без проблем.


Також було створено файл у файловій системі debugfs.

.. code-block:: c

	debugfs_file = debugfs_create_file(FILE, 0777, debugfs_folder, NULL, &debugfs_fops);

.. code-block:: c

	struct dentry * debugfs_create_file (const char *name,
 		mode_t mode,
 		struct dentry *parent,
 		void *data,
 		const struct file_operations *fops);

де,
	* *name* - вказівник на рядок, що містить ім'я файлу для створення;
	* *mode* - права файлу;
	* *parent* - вказівник на "батьківський" dentry для цього файлу. Це повинен бути каталог dentry, якщо він встановлений. Якщо цей параметр має значення NULL, файл буде створений в корені файлової системи debugfs.
	* *data* - вказіваник на те, що отримувач захоче отримати пізніше.
	* *fops* - вказівник на *struct file_operations*, яка повинна використовуватися для цього файлу.


Було і використано функцію видалення катлогу

.. code-block:: c

	void debugfs_remove_recursive (struct dentry * dentry);

де,
	* *dentry* - вказівник на каталог, який потрібно видалити.
	
:Короткий опис: ця функція рекурсивно видаляє дерево каталогів у debugfs, які були створені дещо раніше за допомогою виклику інших функцій debugfs (наприклад, *debugfs_create_file* або її варіантів)

Структура *file_operations* виглядає наступним чином:

.. code-block:: c

	static struct file_operations debugfs_fops = {
		.open =		&debugfs_open,
		.release =		&debugfs_release,
		.read =		&debugfs_read,
		.write =		&debugfs_write,
	};

QEMU
____


:QEMU: вільна програма з відкритим вихідним кодом для емуляції апаратного забезпечення різних платформ.

Програма може працювати в **Windows**, **Linux**, **MacOS** і навіть на **Android**.

**QEMU може емулювати такі архітектури**
	* x86 (32 і 64 біт);
	* ARM, SPARC;
	* PowerPC (32 і 64 біт);
	* MIPS, m68k (Coldfire);
	* SH-4;
	* CRISv2;
	* Alpha;
	* MicroBlaze.

**Програма QEMU мають наступні переваги та особливості:**

#. Може зберігати і відновити стан віртуальної машини з усіма запущеними програмами. Гостьовий операційній системі не потрібно патчів для запуску всередині QEMU.
#. Не потрібні прав адміністратора для запуску, якщо не використовуються додаткові модулі ядра для підвищення швидкості (наприклад, KQEMU), або коли використовуються деякі режими його моделі підключення до мережі.
#. Підтримує два режими емуляції: призначений для користувача режим ``[User-mode]`` і системний режим ``[System-mode]``.
		* Призначений для користувача режим емуляції дозволяє процесу, створеному на одному процесорі, працювати на іншому (виконується динамічний переклад інструкцій для приймаючої процесора і конвертація системних викликів Linux).
		* Системний режим емуляції дозволяє емулювати систему цілком, включаючи процесор і різноманітну периферію.


SysRq
_____

Теорія 
~~~~~~

``SysRq або «СSystem Request»``, також відомий як **Magic Keys**, який дозволяє відправляти деякі конкретні інструкції безпосередньо в ядро *Linux*.

Для того щоб включити *sysrq*, потрібно відобразити "1" у файл ``/proc/sys/kernel/sysrq``

Нижче, наведено інші параметри, які можна показати в даному файлі [3]_:

* 0 - повністю відключити sysrq
* 1 - включити всі функції sysrq
* > 1 - бітова маска для вирішення певних функцій sysrq
* 2 = 0x2 - включити контроль рівня реєстрації консолі
* 4 = 0x4 - включити управління клавіатурою
* 8 = 0x8 - включити налагодження dumps процесів і т. Д.
* 16 = 0x10 - включити команду синхронізації
* 32 = 0x20 - увімкнути перезапис лише для читання
* 64 = 0x40 - включити сигналізацію процесів (term, kill, oom-kill)
* 128 = 0x80 - дозволити перезавантаження / відключення живлення
* 256 = 0x100 - дозволити виконання всіх завдань RT

**Типи подій SysRq:**

Key **m** - скинути інформацію про розподіл пам'яті;
Key **t** - інформація про стан потоку dump;
Key **p** - скинути поточні регістри процесора і флаги;
Key **c** - умисне падіння системи (паніка ядра). Корисно для захоплення vmcore через kdump;
Key **s** - терміново синхронізувати всі змонтовані файлові системи;
Key **u** - терміново перемонтувати всі файлові системи тільки для читання;
Key **b** - терміново перезавантажити машину;
Key **o** - терміново вимкніть машину (якщо вона налаштована і підтримується);
Key **f** - запустити  Out Of Memory Killer (OOM);
Key **w** - скидає задачі, які знаходяться в безперервному (заблокованому) стані.

Підготовка ядра
_______________

Для початку було викачано ``source code`` "ванільного" ядра **Linux** версії *5.3.8* за наступним `посилання <https://www.kernel.org/>`_. 
Потім за допомогою гайду [4]_  було зібрано ядро та створений ``userland`` для роботи в **qemu**. Для збірки ядра була використана ціль ``alldefconfig`` для того щоб зменшити розмір образу ядра та скоротити час завантаження. Але все ж для комфортної роботи з модулем потрібно вручну підключити деякі функції, які відключені за замовчуванням при використанні даної цілі. Для цього можна використовувати різні конфігуратори ядра, такі як: 
``nconfig, xconfig, menuconfig`` та інші. В даній роботі було використано ``menucofig``, а також деякі функції підключено напряму у файлі ``.config``.
Була включена підтримка *RAM* файлової системи, дебагу ядра, підтримка GDB, модулів ядра та можливість їх (примусового) завантаження та вивантаження.

Тепер поговоримо про включення власного модуля в ядро. Вихідний код модулю було додано в папку з вихідним кодом ядра, а саме в папку -
**drivers**. Далі було створено конфігураційний файл ``Kconfig``:

.. code-block:: 

  #
  # hivemod as part of kernel source
  #
  
  menu "hivemod Driver"
  
  config HIVEMOD
	  tristate "hivemod module"
	  default y
	  help
      hivemod kernel module integrated as part of kernel source.
     
  endmenu

А також створено ``Makefile``: 

.. code-block:: Makefile

  obj-$(CONFIG_HIVEMOD) += hivemod.o
  MY_CFLAGS += -g -DDEBUG
  ccflags-y += ${MY_CFLAGS}
  CC += ${MY_CFLAGS}

  all:
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

  debug:
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules EXTRA_CFLAGS="$(MY_CFLAGS)"

  clean:
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
    
Також були додадані відповідні рядки в загальний ``Kconfig`` файл:

.. code-block:: 

  source "drivers/hivemod/Kconfig"  
  
Та загальний Makefile:

.. code-block:: Makefile

  obj-$(CONFIG_HIVEMOD)	+= hivemod/

GDB
___

Теорія
~~~~~~

GDB, відладчик проекту GNU, дозволяє вам бачити, що відбувається "всередині" інший програми під час її виконання - або що інша програма робила в момент її збою.

GDB може виконувати дії чотирьох основних типів, для того щоб допомогти виявити помилку:

* Почати виконання програми, перед цим задати все, що може вплинути на її поведінку;
* Зупинити програму при зазначених умовах;
* Дослідити, чому програма зупинилася;
* Змінити програму, так щоб була можливість експериментувати з усуненням ефектів однієї помилки і продовжити виявлення інших.

**Деякі команди, які використовуються в GDB:**

* ``q`` - вихід з  GDB;
* ``continue (c)`` - відновлює запуск програми до наступного breakpoint-а або помилки;
* ``run (r)`` - запускає програму до breakpoint або помилки;

--------------------------------------------

**Команди для breakpoint**

**Breakpoint** - це спосіб повідомити *GDB*, що користувач прагне щоб він зупинив програму на певних рядках коду. Також є можливість зупинити програму, коли вона викликає певні функції. Після того, як програма припинила свою роботу, можна подивитися в пам'ять і побачити, які значення всіх програмних змінних, вичитати стек і виконати виконання заданої програми.



* ``info breakpoints (i b)`` - список breakpoints;
* ``info break`` - список номерів breakpoints;
* ``b main``- ставить breakpoint на початок програми;
* ``b`` - ставить breakpoint на даному рядку;
* ``b N`` - ставить breakpoint на лінії N
* ``delete (d) N`` - видаляє breakpoint і зупиняє за номером N;
* ``next (n)`` - команда для виконання наступної інструкції, після того як вона зустріла breakpoint
* ``disable [breakpoint number 1] [breakpoint number 2]`` - замість того, щоб видалити або зняти контрольні точки, можна їх включити в потрібний момент;
* ``enable [breakpoint number 1] [breakpoint number 2]`` - для того, щоб включити відключені точки;

--------------------------------------------

* ``p var`` - друкує значення зміної *var* на даний момент


Робота з GDB
~~~~~~~~~~~~

Перед тим як працювати в **gdb** необхідно запустити викачане ядро у середовищі **qemu**. Для цього використано наступну команду:

.. code-block::

  qemu-system-x86_64 -kernel obj/linux-x86-alldefconfig/arch/x86_64/boot/bzImage 
  -initrd obj/initramfs-busybox-x86.cpio.gz -nographic -append "console=ttyS0 nokaslr" -enable-kvm -S -s

Дана команда запускає ядро образ якого вказано одразу після ключа ``-kernel``. Ключ ``-S`` каже **qemu** зупинити ядро не запускаючи його, саме в такому стані до нього можна підключитися за допомогою **gdb**. Також схожий ключ ``-s``, різниця між якими лише у верхньому/нижньому регістрі, дозволяє нам підключитися до даного ядра за допомогою **gdb**, адже даний ключ відкривае gdbserver за допомогою **TCP**, порт 1234.

Для початку роботи з **gdb**  необхідно передати йому файл **vmlinux** який відповідає ядру, яке збираємося дебажити.

.. code-block:: 

  gdb ./obj/linux-x86-alldefconfig/vmlinux

Після чого необхідно під'єднати gdb до нашого ядра, це робиться за допомогою команди:

.. code-block:: 
  
  target remote localhost:1234

Яка в свою чергу починае слухати заздалегідь налаштований порт *1234*.

Наступним кроком необхідно підключити наш модуль до ядра, для цього в **gdb** необхідно прописати ``c``, що в свою чергу запустить ядро в **qemu**, 
а вже в ядрі:

.. code-block:: 

  insmod hivemod.ko

Після чого в папці ``sys/module/hivemod/sections`` необхідно вичитати значення файлів ``.text .data .bss.``

.. image:: img/addr.png

Дані значення необхідно передати в наступну команду ``add-symbol-file`` для зчитування символів для дебагу.

.. image:: img/addr_w.png

Після чого **gdb** буде відомо про наш модуль, та про змінні які в ньому містяться. Тож тепер є можливість вичитувати їх.

.. image:: img/example.png

Джерела
_______

.. [1] https://wiki.gentoo.org/wiki/Kernel/Configuration
.. [2] https://www.kernel.org/doc/Documentation/filesystems/debugfs.txt
.. [3] https://ngelinux.com/what-is-proc-sysrq-trigger-in-linux-and-how-to-use-sysrq-kernel-feature/
.. [4] https://mgalgs.github.io/2015/05/16/how-to-build-a-custom-linux-kernel-for-qemu-2015-edition.html

