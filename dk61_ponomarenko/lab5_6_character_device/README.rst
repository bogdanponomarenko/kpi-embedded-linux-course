Лабораторна робота № 5-6
========================

``Тема``: Символьні пристрої
++++++++++++++++++++++++++++


Символьні пристрої
~~~~~~~~~~~~~~~~~~

Спосіб бачення пристроїв в `Linux` розділяється на *три фундаментальні типи*. Кожен модуль зазвичай реалізований як один з цих типів і таким чином класифікується як **символьний модуль**, **блочний модуль**, або **мережевий модуль**. Такий поділ модулів на різні типи або класи не є жорстким; програміст може при бажанні створювати великі модулі, що містять різні драйвера в одній частині коду.

**Символьний пристрій** - це такий пристроїв, до якого можна звертатися як до потоку байтів (так само як до файлу). Драйвер символьного пристрою відповідає за реалізацію цієї поведінки. Даний драйвер, зазвичай,  підтримує системні виклики, такі як: *open*, *close*, *read* і *write*. Прикладами символьних пристроїв є: текстовий екран ``(/dev/console)`` і послідовні порти ``(/dev/ttyS0 і подібні)``. Для звернення до символьних пристроїв використовують вузли *(node)* файлової системи, такі як ``/dev/tty1`` і ``/dev/lp0``. Єдине **важлива відмінність** між символьними пристроями і звичайними файлами - це можливість рухатися вперед і назад у *звичайному файлі*, в той час як більшість *символьних пристроїв* - це тільки канали даних, в яких існує спосіб звертатися лише послідовно.

Файл пристрої ``/dev/ttyS0`` послідовного порту:

.. code-block:: c

	crw-rw---- 1 root uucp 4, 64 окт  7  2019 /dev/ttyS0

Перший символ в розширеному виведенні ``ls (ls -l)`` для символьних пристроїв - буква *c (character)*. Замість розміру файлу в п'ятому полі таблиці показується два числа - **мажорний** і **мінорний** номер пристрою *(major and minor numbers)*. Перший номер відображає *тип пристрою*, а другий - *номер пристрою в системі або режим його роботи*.


register_chrdev_region()
""""""""""""""""""""""""

Однією з найперших дій, які потрібно зробити драйверу при створенні символьного пристрою, це отримати один або декілька номерів пристроїв для роботи з ним. Саме функція **register_chrdev_region()** виконує цю задачу. Вона знаходиться у ``#include <linux/fs.h>``.

.. code-block:: c

	int register_chrdev_region(dev_t first, unsigned int count, char *name);

де

* **first** - це перший в бажаному діапазоні номер пристрою;
* **count** - необхідна кількість послідовних номерів пристрою;
* **name** - назва пристрою або є драйверу.

Як і в більшості функцій ядра, дана функція буде повертати **0**, якщо операція виділення успішно виконалася. В протилежному випадку, коли виникла помилка, то буде повернуто від'ємне значення.

Проте, дуже часто може бути така ситуація, що невідомо які старші номера пристрою будуть використовуватися. Тому в такому випадку, ядро може самостійсно виділяти старший номер, для цього використовується функція `alloc_chrdev_region()`_

alloc_chrdev_region()
"""""""""""""""""""""

.. code-block:: c

	int alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, char *name);

де 

* **dev** - вихідний параметр для першого присвоєного числа;
* **firstminor** - містить значення першого молодшого номера для використання;
* **count** - необхідна кількість послідовних номерів пристрою;
* **name** -  назва пристрою або ж драйверу.

Короткий опис:
	Функція виділяє діапазон номерів сивольних пристроїв. Основне число буде вибиратися динамічно, і повертається в 
	``dev/`` Відповідно при успішній роботі повертає **0**, а при помилці - від'ємне значення.

lseek()
"""""""

``lseek()`` - встановити зміщення для позиціонування операцій *читання/запису*.

.. code-block:: c

	off_t lseek(int fd, off_t offset, int whence);

Змінює поточну позицію читання/запису в файлі, в заданому дескрипторі *fd*. Параметр *whence* може приймати одне з наступних значень:

* SEEK_SET
	Зміщення вставновлює в **offset** байт від початку файлу.
* SEEK_CUR
        Зміщення встановлює на **offset** байт відносно заданої позиції
* SEEK_END
        Зміщення встановлюється, як розмір файду + **offset** байт.

При успішному виконані **lseek** повертає зміщення в байтах нової позиції відносно початку файлу. В іншому випадку, повертається значення **(off_t) -1** і **errno** показує помилки.

**Основні помилки:**

* EBADF  **fd** не є дескриптором відкритого файлу.
* EINVAL **whence** не є одним із значень *SEEK_SET, SEEK_CUR, SEEK_END* або ж зміщення у файлі, яке вийшло в результаті є від'ємним.

Реалізаціє виглядає наступним чином:

.. code-block:: c

	static loff_t cdev_lseek(struct file *file, loff_t offset, int orig)
	{
		loff_t new_offset = 0;	
		switch(orig) {
		case SEEK_SET: 
			new_offset = offset; 
			break;
		case SEEK_CUR: 
			new_offset = file->f_pos + offset;
			break;
		case SEEK_END: 
			new_offset = buffsize - offset; 
			break;
		default:
			new_offset =  EINVAL;
		}
		file->f_pos = new_offset;
		return new_offset;
	}


file_operations()
"""""""""""""""""

Розглянемо коротко, що таке **file_operations**.

Структура **file_operations** оголошена у файлах ``linux/fs.h``.
Структура являє собою масив вказівників на різні функції. Операції, зазвичай, відповідають за реалізацію системних викликів.

Драйвер в більшості випадків, реалізує не всі функції в заданій структурі. Для кожної конкретної задачі, потрібний свій список функцій.
Нижче наведенно, які саме операції будуть використані в даній лабораторній роботі:

.. code-block:: c

	static struct file_operations hive_fops = {
		.open =    &cdev_open,
		.release = &cdev_release,
		.read =    &cdev_read,
		.write =   &cdev_write,
		.llseek =   &cdev_lseek,
		// required to prevent module unloading while fops are in use
		.owner =   THIS_MODULE,
	};

Функції, які не використано заповнюються "пустими" вказівниками - **NULL**.

ioctl()
"""""""

Системний виклик **ioctl()** - це універсальний засіб управління апаратними пристроями.
Завдяки запитам **ioctl()** можна керувати багатьма оперативними характеристиками спеціальних символьних файлів.
Для використання такої функцій слід підключити ``<linux/ioctl.h>``.

.. code-block:: c
	int ioctl(int fd, int cmd, ...);

Завдяки невизначеному списку параметрів, даний прототип сильно виділяється із списку системних викликів *Unix*, які, зазвичай, представлені фіксованим числом формальних параметрів. Однак, в реальній системі, системний виклик не може мати змінне число параметрів. Системні виклики повинні мати чітко визачену кількість аргументів, так як призначені для користувача програми, можуть отримати доступ до них тільки через апаратну частину.

**Першим аргументом** функції є дескриптор файлу того пристрою, яким потрібно керувати. **Другий аргумент** - це код запиту, що позначає операцію, яка буде виконуватися. Різним пристроям відповідають різні запити. Залежно від запиту функції **ioctl()** можуть знадобитися додаткові аргументи. **Третій аргумент** - нетипізований вказівник на пам'ять. Це традиційно **char * argp**.

Зазвичай, при успішному завершенні роботи повертається нуль. У деяких **ioctl()** запитах повернене значення вважається вихідним параметром і при успішному завершенні повертається позитивне значення. У разі помилки повертається **-1** і значення **errno** встановлюється відповідним чином. 
Основні помилки:

*  **EBADF** - **fd** не є дескриптором відкритого файлу.
*  **ENOTTY** - **fd** не пов'язаний з символом спеціального пристрою.
*  **ENOTTY** - вказаний запит не застосовується до виду об'єкта.
*  **EFAULT** - **argp** посилається на недоступну область пам'яті.

tree
~~~~

**Бінарне дерево** - це ієрархічна структура даних, в якій кожен вузол має значення (воно ж є в даному випадку і ключем) і посилання на лівого і правого нащадка. Вузол, що знаходиться на самому верхньому рівні (який не є чиїмось нащадком) називається **коренем**. Вузли, які не мають нащадків (обидва нащадка яких дорівнюють NULL) називаються **листям**.

Двійкове дерево або є порожнім, або складається з даних і двох піддерев (кожне з яких може бути порожнім). Очевидним, але важливим для розуміння фактом є те, що кожне піддерево в свою чергу теж є деревом. Якщо у деякого вузла обидва піддерева порожні, то він називається листовим вузлом (листовою вершиною) або кінцевим (термінальним) вузлом.

Візуальне представлення бінарного дерева наведено нижче:

	.. image:: img/tree.png

Хід роботи
__________

1. Change this to proper associative array or tree
""""""""""""""""""""""""""""""""""""""""""""""""""

В даній лабораторній роботі знову розглядається тема структур даних в ядрі. `Зв'язний список <https://github.com/DovzhenkoD/kpi-embedded-linux-course/tree/dev/dk62_dovzhenko/lab3_kernel_threads#linux>`_  було розглянуто дещо раніше. 
В даному випадку використовується структура даних у вигляді дерева, в якому кожна вершина має не більше двох "дітей". 
Його реалізацію можна побачити у файлі `hivemod.c <src>`__.
Більш детально про дерева можна прочитати тут -> `tree`_.

2. Fix to make it zero'ed first
"""""""""""""""""""""""""""""""

До виправлення:

.. code-block:: c

	char *buf = kmalloc(sizeof(*buf) * buffsize, GFP_KERNEL);

Після виправлення:

.. code-block:: c

	char *buf = kzalloc(sizeof(*buf) * buffsize, GFP_KERNEL);

Кодова база ядра містить багато функцій, які виділяють пам'ять за допомогою **kmalloc ()**, а потім обнуляют її за допомогою **memset ()**. Згодом Пекка Енберг прийшов до висновку, що більшу частину цього коду можна очистити за допомогою **kcalloc ()**.

**kcalloc ()** має цей прототип:

.. code-block:: c

	void * kcalloc (size_t n, size_t size, unsigned int __nocast gfp_flags);

Але тут є один недолік: далеко не всі викликаючі абоненти фактично повинні виділити масив елементів, тому в більшості випадків додатковий аргумент **size_t n** не потрібно. Кожен екземпляр цього аргументу додає деякий об'єм до розміру ядра, і з часом цей простір збільшується. Тому Ендрю Мортон запропнував нове рішення створити ще одну функцію розподілу:

.. code-block:: c

	void * kzalloc (size_t size, unsigned int __nocast gfp_flags);

Ця функція повертає один обнулений елемент.

3. Add buffer read logic. Make sure seek operations work
""""""""""""""""""""""""""""""""""""""""""""""""""""""""

.. code-block:: c
	
	unsigned long copy_to_user (void __user *to,
 		const void *from,
		unsigned long n);

де, використовуюють такі аргументи:

		* **to** - адреса призначення, в просторі користувача;
		* **from** - адреса джерела в просторі ядра;
		* **n** - кількість байтів для копіювання.

Короткий опис:
	Контекст користувача. Ця функція може спати.
	Копіює дані з простору ядра в простір користувача.
	Повертає кількість байтів, які неможливо скопіювати. При успіху це буде нуль.

.. code-block:: c

	static ssize_t cdev_read(struct file *file, char __user *buf, size_t count, 
			loff_t *loff)
	{
	struct hive_flist_item *item = hive_flist_get(file);
	if (NULL == item)
		return -EBADF;

	int max_leng;
	int bytes_to_read;
	int read_b;

	max_leng = buffsize - *loff;
	if (max_leng > count)
		bytes_to_read = count;
	else
		bytes_to_read = max_leng;
	if (bytes_to_read == 0)
		printk(KERN_INFO "The end of device\n");
	read_b = bytes_to_read - copy_to_user(buf, item->buffer + *loff, 
		bytes_to_read);
	*loff += read_b;	
	return read_b;
	}
	
4. Add buffer write logic. Make sure seek operations work
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Копіювання даних з постору користувача відбувається за допомогою наступною операцією:

.. code-block:: c

	unsigned long copy_from_user (void* to,
 		const void __user *from,
 		unsigned long n);

де, використовуюють такі аргументи:

		* **to** - адреса призначення, в просторі ядра;
		* **from** - адреса джерела в просторі користувача;
		* **n** - кількість байтів для копіювання.

Короткий опис:
	Тільки для користувача. Ця функція може спати. 
	Копіює дані з простору користувача в простір ядра.
	Повертає кількість байтів, які не вдалося скопіювати. У разі успіху це буде нуль.

Написана функці наведена нижче:

.. code-block:: c

	static ssize_t cdev_write(struct file *file, const char __user *buf, 
			size_t count, loff_t *loff)
	{
	struct hive_flist_item *item = hive_flist_get(file);
	if (NULL == item)
		return -EBADF;
	int max_leng;
	int bytes_to_write;
	int write_b;
	max_leng = buffsize - *loff;
	if (max_leng > count)
		bytes_to_write = count;
	else
		bytes_to_write = max_leng;
	
	if (bytes_to_write == 0) {
		printk(KERN_INFO "END\n");
	}
	write_b = bytes_to_write - copy_from_user(item->buffer + *loff, buf, 
		bytes_to_write);
	item->buffer[bytes_to_write] = '\0';
	printk(KERN_INFO "The end of device, device has been wrtitten %d", 
		write_b);
	*loff += write_b;

	return write_b;
	}


Для того, щоб запезпечувалося читання та запис в пристрій, вирішено добавити функцію `lseek()`_. 


5. add ioctl to append magic phrase to buffer conents to make these bees twerk
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Більш детально про дану функцію, можна прочитати -> `ioctl()`_.
В файлі  `user_app_test.c <src>`__ викликаємо цю функцію, з операцією, яка означає, що використовується "магічна фраза", і саме вона буде записуватися в буфер, а потім відбувається її зчитування.

.. code-block:: c

	ioctl(fd_2, BEES_TWERK, &magic_phrase);



6. add ioctl to select buffer size
""""""""""""""""""""""""""""""""""

Було створено функцію ``static long cdev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)``. 
В ній реалізано операцію, коли визначаємо новий розмір нашого буфера.

.. code-block:: c

	copy_from_user(&buffsize, (int *)arg, sizeof(buffsize));
	printk(KERN_INFO "Buffsize = %d\n", buffsize);	

Для цього в програмі user_space викликаємо ``ioctl(fd, SEL_BUF_SIZE, (int *) &num);`` і передаємо розмір буфера, та в якості другого параметру - потрібну операцію.

Кінцевий вигляд **static long cdev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)** є таким:

.. code-block:: c

	static long cdev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
	{	
	struct hive_flist_item *item = hive_flist_get(file);
	switch(cmd) {
		case BEES_TWERK:
			copy_from_user(item->buffer, (char *)arg, 
				strlen((char *)arg));
			printk(KERN_INFO "Magic phrase = %s\n", item->buffer);
			break;
		case SEL_BUF_SIZE:
			copy_from_user(&buffsize, (int *)arg, sizeof(buffsize));
			printk(KERN_INFO "Buffsize = %d\n", buffsize);	
			break;
		}
	return 0;
	}

7. add stuff here to make module register itself in /dev
""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Для того, щоб використовувати *character driver*, спершу слід зареєструвати його в системі. Потім - виставити його в *user space*.

* ``cdev_init()`` - ініціалізувати структуру **cdev**;
* ``cdev_add()`` - додати символьний пристрій до системи;
* ``class_create()`` - створює новий клас пристроїв для пристрою;
* ``device_create()`` - створює пристрій та реєструє його за допомогою *sysfs*.
	
Функції **cdev_init()** та **cdev_add()** виконують реєстрацію символьних пристроїв. 
Коли функція **cdev_add** успішно виконується, пристрій працює в активному режимі і ядро ​​може викликати свої операції.

Щоб отримати доступ до цього пристрою з простору користувача, слід створити вузол пристрою в ``/dev``. Для цього потрібно створити клас віртуального пристрою за допомогою **class_create()**, слід його зареєєструвати в  ``sysfs`` за допомогою функції **device_create()**. 
**device_create()** створить файл пристрою в ``/dev``.

Для початку використання всіх вище перерахованих функцій потрібно підключити ``#include <linux/cdev.h>``, де і відбувається визначення структури, а також пов'язані з нею допоміжні функції.


Результати
__________


Було виконано тестування операцій читання з простору користувача, та запис в простір користувача. 
Нижче наведено результат роботи тестової програми в просторі користувача, також, продемонстровано лог ядра в якому відображаються результати роботи символьного пристрою.

.. code-block:: c

	Open a device 2: 4
	Open a device 1: 3
	SOME MAGIC _read_: Wow, we made these bees TWERK!

	Type a buffersize and press ENTER:
	100
	Type some text to write and press ENTER:
	Hello 
	buf is: 6
	Written line: Hello
	Press ENTER to to read!
	Read line: Hello


Вижче відбувається відпрацювання тестової програми. Записано магічну фразу в перший пристрій, за допомогою системного виклику **write()**. За допоомгою виклику **lseek()**, виставляємо вказівник на початок рядка, і виконуємо читання за допомогою виклику **read()**. Як видно, операцію читання та запису було успішно реалізовано.

Наступним кроом було те, що користувач сам задає розмір потрібного йому буфера, записує свій текст в буфер, і зчитує його.

.. code-block:: c

	[  628.428432] hivemod: New file entry 0000000029329ed1 created
	[  628.428442] newv#000000004dd366af, oldv#0000000029329ed1  left
	[  628.428444] hivemod: New file entry 000000004dd366af created
	[  628.428592] Magic phrase = Wow, we made these bees TWERK!
	[  632.336533] Buffsize = 100
	[  634.520069] The end of device, device has been wrtitten 6
	[  635.647516] Hello
	[  635.647525] hivemod: File entry 0000000029329ed1 unlinked
	[  635.647533] Wow, we made these bees TWERK!
	[  635.647534] hivemod: File entry 000000004dd366af unlinked

В лозі ядра видно результати системних викликів з простору користувача. 

